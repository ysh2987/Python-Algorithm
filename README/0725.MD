# 2021년 7월 25일
# 그리디 알고리즘
- 그리디 알고리즘은(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.
- 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
- 그리디 해법은 그 정당성 분석이 중요하다.
    - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.

## <문제> 거스름 돈
***
- 당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수입니다.
```python
a = int(input())
b = [500, 100, 50, 10]
dong = 0
for i in b :
    dong += a // i # 거스른 동전의 수를 dong에 추가해준다
    a = a % i # 나머지를 다시 위쪽 a로 넘겨준다 
print(dong)
```
- 화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 O(K)입다
- 이 알고리즘의 시간 복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.
***
## <문제> 1이 될 때까지 
- 어떤수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고한다. 단, 두번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
```
예를 들어 N = 17, K = 4일 경우
```
1) 17 - 1 = 16
2) 16 // 4 = 4
3) 4 // 4 = 1
***
- 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.
```python
n, k = map(int, input().split())
result = 0

while n != 1 :
    if n % k != 0 :
        n = n -1
        result += 1
    else : 
        n = n / k
        result += 1
print(result)
```
<br></br>

# 구현
- 구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정입니다.
- 흔히 알고리즘 대회에서 구현 유형의 문제란 무엇을 의미할까 ?
    - 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다.
- 구현 유형의 예시는 다음과 같다
    - 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
    - 실수 연산을 다루고, 특정 소수점 자리까지 출력해야하는 문제
    - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
    - 적절한 라이브러리를 찾아서 사용해야 하는 문제


